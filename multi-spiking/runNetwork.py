import math
from copy import deepcopy
import json
import pickle
import argparse

parser = argparse.ArgumentParser()

parser.add_argument("-w", "--weights", default='weights.json', type=str,
                    help="File containing weights generated by training")
parser.add_argument('testCases',
                    help="A file containing test cases for the network")

args = parser.parse_args()


synapseWeight = json.load(open(args.weights, 'r'))
testCases = pickle.load(open(args.testCases, 'rb'))

neuronThreshold = 1
synapseNumber = 4
network = [21, 5, 1]
simulationTime = 25
encodingInterval = 10
refractorinessDecay = 80
latestOutputSpike = 20
learningRate = 0.005
maxEpoch = 500
timeDecay = encodingInterval + 1

synapseDelayDelta = int(latestOutputSpike / synapseNumber)
synapseDelay = [1 + (n * synapseDelayDelta) for n in range(synapseNumber)]


def alpha(t):
    if t > 0:
        return (t / timeDecay) * math.exp(1 - (t/timeDecay))
    else:
        return 0


def refractoriness(time):
    if time > 0:
        return -2 * neuronThreshold * math.exp(-time/refractorinessDecay)
    else:
        return 0

def runNetwork(neuronInput, synapseWeight):
    networkOutput = [deepcopy(neuronInput)]
    networkInternalState = []
    layerOutput = []


    for a in range(0, len(network) - 1):
        outputNeuronNetworkOutput = []
        layerInternalState = []
        for b in range(0, network[a + 1]):
            # placeholder for outputs
            time = 0
            # counter for time
            output = []
            neuronInternalState = []
            while time <= simulationTime:
                activationFunction = (time > min(min(neuronInput)))
                internalState = 0
                if len(output) > 0:
                    activationFunction = ((time - output[-1]) > 2)
                    # heuristic rule: prevent spikes that are <= 2 ms apart
                if a == (len(network) - 2):
                    activationFunction *= (1 - len(output))
                if activationFunction == 1:
                    for x in range(0, network[a]):
                        for y in range(0, synapseNumber):
                            for z in range(0, len(neuronInput[x])):
                                adjustedTime = -neuronInput[x][z] - synapseDelay[y] + time
                                internalState += synapseWeight[a][b][x][y] * alpha(adjustedTime)
            # summing alpha function values for all received inputs to a neuron
            # an input is recieved from the previous layer when the sum of the
            # input time and the delay is equal to the time
                    if (len(output) > 0)*(internalState > 1):
                        internalState += refractoriness(time - output[-1])
                # adding the refractoriness term for the most recent output
                    if internalState > neuronThreshold:
                        output.append(time)
                # storing output time if the neuron outputs
                neuronInternalState.append(internalState)
                if time == simulationTime:
                    if len(output) == 0:
                        output.append(neuronInternalState.index(max(neuronInternalState)))
                        # heuristic rule
                    layerOutput.append(output)
                time = time + 1
            layerInternalState.append(neuronInternalState)
            outputNeuronNetworkOutput.append(output)
        networkInternalState.append(layerInternalState)
        neuronInput = deepcopy(layerOutput)
        networkOutput.append(outputNeuronNetworkOutput)
    return networkOutput


for (neuronInput, expectedOutput) in testCases:
    networkOutput = runNetwork(neuronInput, synapseWeight)
    trueOutput = expectedOutput[0]
    predictedOutput = networkOutput[-1][0][0]
    print([predictedOutput, trueOutput])
